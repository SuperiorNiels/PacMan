if(ac->path.empty())
            {
                ac->path = pathfinder->getPath(pc->x, pc->y, target->x, target->y);
                //pathfinder->printPath(ac->path);
            }

            if(mc->state == MOVING)
                continue;

            PathNode next = ac->path[ac->path.size()-1];
            ac->path.pop_back();

            int direction = 0;
            for(int i=0;i<5;i++)
            {
                int new_x = pc->x + movement_vector[i][0];
                int new_y = pc->y + movement_vector[i][1];
                if(new_x == next.getX() && new_y == next.getY())
                {
                    direction = i;
                    break;
                }
            }

            if(direction == 0 || (pc->x == target->x && pc->y == target->y))
                mc->wanted_dir = STOP;
            if(direction == 1)
                mc->wanted_dir = LEFT;
            if(direction == 2)
                mc->wanted_dir = RIGHT;
            if(direction == 3)
                mc->wanted_dir = UP;
            if(direction == 4)
                mc->wanted_dir = DOWN;